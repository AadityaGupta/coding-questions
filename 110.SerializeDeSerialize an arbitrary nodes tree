/*

SerializeDeSerialize an arbitrary nodes tree

*/

/*

solution: preorder traversal
O(n) time
*/



#include<iostream>
#include<vector>
using namespace std;
struct NODE 
{
    int nVal;
    vector<NODE*> vec;
 
    NODE(int n) : nVal(n), vec() {}
};
 
void _inner_serial(NODE* pNode, char*& p)
{
    //if (NULL == pNode)
     //   return;
	
	 
    itoa(pNode->nVal, p, 10);
    p += strlen(p);
	
    int num= pNode->vec.size();
	itoa(num, p, 10);
    p += strlen(p);
	

	if(pNode->vec.size()==0) return;
    
     //cout<<*p<<endl;
	
    for (vector<NODE*>::iterator it = pNode->vec.begin();
        it != pNode->vec.end(); it++)
        _inner_serial(*it, p);
}
 
char* Serialize(NODE* pRoot, char mem[])
{
    if (NULL == mem || NULL == pRoot)
        return NULL;
 
    char* p = mem;
    _inner_serial(pRoot, p);
    p++;
	*p='\0';
    return mem;
}
int Proc(const char*& p)
{
    
 
    int nVal = 0;
    while (*p >= '0' && *p <= '9' & *p!=' ')
        nVal = 10*nVal + *p++ - '0';
    p++;
    return nVal;
}
 
NODE* _inner_deserial(const char*& p)
{
	
    
	int val=Proc(p);
    NODE* pRet = new NODE(val);
	val=Proc(p);

	int n = val;
   

    for (int i = 0; i < n; i++)
        pRet->vec.push_back(_inner_deserial(p));
 
    return pRet;
}
 
NODE* DeSerialize(const char mem[])
{
    if (NULL == mem) 
        return NULL;
 
    const char* p = mem;
    return _inner_deserial(p);
}

int main()
{
    
	NODE *root1=new NODE(3);
	NODE *p1=new NODE(1);
	

	NODE *p2=new NODE(2);
	
	NODE *p3=new NODE(4);
	
	root1->vec.push_back(p1);
	root1->vec.push_back(p2);
	root1->vec.push_back(p3);
	
	
	char str[]="";

	Serialize(root1,str);
	cout<<str<<endl;
    

	
	const char mem1[]="3 3 1 0 2 0 4 0";
	NODE *root=DeSerialize(mem1);
	cout<<root->nVal<<endl;
	for (vector<NODE*>::iterator it = root->vec.begin();it != root->vec.end(); it++)
		cout<<(*it)->nVal<<endl;

}
