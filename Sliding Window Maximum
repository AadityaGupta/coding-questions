/*

Given an array and an integer k, find the maximum for each and every contiguous subarray of size k.


Input :
a[] = {1, 2, 3, 1, 4, 5, 2, 3, 6}
k = 3
Output :
3 3 4 5 5 5 6

*/

#include<iostream>
#include<queue>
using namespace std;

/*

solution1: whenever the window moves, calculate the maximal number in the window. 
O(nk) time, O(1) space

*/

/*

solution2: use maximal heep to store k numbers.
O(nlogn) time, O(n) space

*/


typedef pair<int, int> Pair;
void maxSlidingWindow2(int A[], int n, int k, int B[])
{
	priority_queue<Pair> Q; 
	for (int i = 0; i < k; i++)
		Q.push(Pair(A[i], i));  
	for (int i = k; i < n; i++) {
		Pair p = Q.top();
		B[i-k] = p.first;
		while (p.second <= i-k) {//pop the old elements not in new window
			Q.pop();
			p = Q.top();
		}
		Q.push(Pair(A[i], i));
	}
	B[n-k] = Q.top().first;
}


/*

solution3:use deque to store k numnbers. 
O(n) time, O(k) space

*/

void maxSlidingWindow3(int A[], int n, int k, int B[]) 
{
  deque<int> Q;
  for (int i = 0; i < k; i++) {
    while (!Q.empty() && A[i] >= A[Q.back()]) //elements in the deque decreaes.
      Q.pop_back();
    Q.push_back(i);
  }
  for (int i = k; i < n; i++) {
    B[i-k] = A[Q.front()];
    while (!Q.empty() && A[i] >= A[Q.back()]) 
      Q.pop_back();
    while (!Q.empty() && Q.front() <= i-k) //pop the old elements not in new window
      Q.pop_front();
    Q.push_back(i);
  }
  B[n-k] = A[Q.front()];
}




int main()
{

  int a[9] = {1, 2, 3, 1, 4, 5, 2, 3, 6};
  int b[7];
  int c[7];
  maxSlidingWindow2(a,9,3,b);
  maxSlidingWindow3(a,9,3,c);
  for(int i=0;i<7;i++)
	  cout<<b[i]<<" ";
  cout<<endl;
  for(int i=0;i<7;i++)
	  cout<<c[i]<<" ";
  cout<<endl;
  return 0;

}

