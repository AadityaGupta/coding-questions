/*
Given an array of integers where each element points to the index of the next element 
how would you detect the longest cycle in this array.

Note: suppose the element of array is in range[0, n-1], where n is the length of array, then there 
must be at least one cycle. If one element points itself, this particular cycle length is 1.

*/

/*
solution: DFS
O(n) time, O(n) space

*/
#include<iostream>
#include<vector>
#include<cassert>
using namespace std;

void dfs(int start, int idx, int arr[], vector<bool>& used, int &len) 
{
     used[idx] = true;
     len++;
     if (!used[arr[idx]]) {
            dfs(start, arr[idx], arr, used, len);
     } else {
            assert(start != idx);//a cycle
     }
     
}


int longestCycle(int arr[], int n)
{

	int maxlen=0;
	int len=0;
	vector<bool> used(n, false);
    for (int i = 0; i <n; ++i) 
	{
      if (!used[i]) 
	  {
           dfs(i, i, arr, used, len);
           if (len > maxlen) 
		   {
                maxlen = len;
           }
    }

    return maxlen;
}



}

int main()
{
	int a[]={3, 2, 1, 4, 0};

	cout<<longestCycle(a, 5)<<endl;

	return 0;

}
